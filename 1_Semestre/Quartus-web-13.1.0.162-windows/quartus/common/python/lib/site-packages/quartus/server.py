# Copyright 2013 Altera Corporation.
# $Header: //acds/rel/13.1/quartus/ccl/py/server.py#1 $

"""
Bottle routes for --webserver
"""

__author__ = "Richard Calvi (rcalvi@altera.com)"
__version__ = "$Revision: #1 $"
__date__ = "$Date: 2013/08/11 $"
__copyright__ = "Copyright 2013 Altera Corporation."


import socket
import traceback
import os
import sys
import threading
import queue
import signal
import time

from quartus.tlock import thread_lock
from quartus.broker import BROKER
from bottle import route, get, post, run, static_file, request, ServerAdapter, server_names

# TODO: Break these routing functions out to separate per-module files
from quartus.project_api import *
from quartus.qhd_api import *
from quartus.lfp_api import *
from quartus.rdb_api import *

# Everything under /htdocs/ is served as a static file under quartus/common/htdocs
@route("/htdocs/<filepath:path>")
def serve_htdocs(filepath):
    exe = sys.executable
    acds = os.path.join(exe, "..", "..", "common", "htdocs")
    acds = os.path.normpath(acds)
    p4 = os.path.join(exe, "..", "..", "..", "..", "p4", "quartus", "htdocs")
    p4 = os.path.normpath(p4)
    if os.environ.get("QDFS_SERVE_HTDOCS_FROM_P4") and os.path.isfile(os.path.join(p4, filepath)):
        htdocs = p4
    else:
        htdocs = acds
    return static_file(filepath, root=htdocs)
    
@route("/")
def home():
    return serve_htdocs("index.html")

def do_tcl(command, wait):
    import quartus.tcl
    result = ""
    if (wait):
        result = quartus.tcl.eval(command)
    else:
        quartus.tcl.post(command)
        result = "Posted command: " + command
    return result
    
# URL looks like /tcl/?wait=1&command=puts%20Hello%20World
@get("/tcl/")
def tcl_get():
    command = request.query.command
    wait = request.query.wait
    return do_tcl(command, wait)
    
@post("/tcl/")
def tcl_post():
    command = request.forms.command
    wait = request.forms.wait
    return do_tcl(command, wait)


##############################################################################
# Server control
##############################################################################

@route("/control/ping/")
def ping():
    return "server is alive with pid=" + str(os.getpid())
    

@route("/control/stop/")
def stop():
    """
    Used to stop the server and exit the process
    """
    BROKER.deregister()
    TERMINATOR.kill()

    return { 'command' : 'terminate', 'status' : 'accepted' }


@route("/control/sleep/")
@thread_lock
def server_sleep():
    """
    Debug function to force the server to take a long time to respond
    """
    timeout = request.query.time
    if timeout:
        timeout = int(timeout) # convert string to integer
    else:
        timeout = 10
    # Sleep for timeout seconds
    time.sleep(timeout)
    return "done sleeping"

##############################################################################
# Bottle infra
##############################################################################


class Terminator(object):
    """
    Worker object to listen for requests to kill this process; the producer of
    such messages comes from the Bottle /control/stop/ API
    """

    def __init__(self):
        self.queue = queue.Queue()

    def __call__(self):
        """
        Worker thread routine to check for messages
        """
        TIMEOUT = 4
        self.name = threading.currentThread().getName()

        while True:
            try:
                sig = self.queue.get(True, None)
                if sig == "terminate":
                    print("Received STOP command, killing self...")
                    time.sleep(1)
                    os.kill(os.getpid(), signal.SIGTERM)
            except queue.Queue.Empty:
                break

    def kill(self):
        self.queue.put("terminate", True)
        

TERMINATOR = Terminator()


def file_write(filename, content):
    """
    Writes content of file to specified filename
    """
    f = open(filename, 'w')
    try:
        f.write(content)
    except Exception as e:
        print("Unexpected error %s when writing %s to %s" % (
            str(e), content, filename))       
    finally:
        f.close()

        
def get_free_port(temp_file):
    """
    Gets first available free socket and write it to temp file. Also
    return it.
    """
    s = socket.socket()

    # From http://docs.python.org/3/library/socket.html:

    # Running an example several times with too small delay between
    # executions could lead to "OSError: [Errno 98] Address already in
    # use."
    # There is a socket flag to set, in order to prevent this, socket.SO_REUSEADDR
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    # Bind to zero, to automatically get a free port from OS:
    # http://stackoverflow.com/questions/11059228/python-socket-bind-without-port
    s.bind(('', 0))
    port = str(s.getsockname()[1])

    # Close it to free
    s.close()

    file_write(temp_file, port)
    return port


class AlteraCherryPyServer(ServerAdapter):
    """
    This is a Bottle 'adapter' or plugin that lets us customize
    how we run CherryPy as the actual WSGI server that Bottle will
    receive HTTP requests from.
    
    See http://bottlepy.org/docs/dev/deployment.html#switching-the-server-backend
    """
    USE_SSL = bool(os.environ.get('QDFS_USE_SSL'))
    
    def run(self, handler): # pragma: no cover
        print("*** Altera CherryPy server adapter")
        from cherrypy import wsgiserver
        
        if self.USE_SSL:
            print("*** Using SSL")
            from cherrypy.wsgiserver.ssl_builtin import BuiltinSSLAdapter
            ssl_certificate = "cacert.pem"
            ssl_private_key = "privkey.pem"
            wsgiserver.CherryPyWSGIServer.ssl_adapter = BuiltinSSLAdapter(ssl_certificate, ssl_private_key, None)

        server = wsgiserver.CherryPyWSGIServer((self.host, self.port), handler, numthreads=20, max=-1)
        
        try:
            server.start()
        finally:
            server.stop()


def start(host="localhost", port=51000, token=None, broker=None, cherry=False):
    """
    Starts Bottle on specified host/port, and registers host/port with
    broker (optional).
    """
    quiet = False # Change to True if and when we really ship this product
    print("Attempting to start web server on http://", host, ":", port, sep='')

    try:
        # Make sure that the port is available
        import socketserver
        server = socketserver.TCPServer((host, port), socketserver.BaseRequestHandler)
        del server

        BROKER.set_broker(broker)
        BROKER.login(token=token)
        BROKER.register(host, port)

        # Start thread that waits to be told to terminate
        thread = threading.Thread(target=TERMINATOR, name="terminator")     
        thread.setDaemon(True)            
        thread.start()

        if cherry:
            run(server=AlteraCherryPyServer, host=host, port=port, quiet=quiet)
        else:
            run(host=host, port=port, quiet=quiet)
    except Exception as e:
        print(e, traceback.format_exc())
        raise(e)

    BROKER.deregister()


def start_cherry(host="localhost", port=51000, token=None, broker=None):
    return start(host, port, token, broker, cherry=True)


def start_bottle(host="localhost", port=51000, token=None, broker=None):
    return start(host, port, token, broker)

