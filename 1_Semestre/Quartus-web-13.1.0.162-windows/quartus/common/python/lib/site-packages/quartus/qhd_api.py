# Copyright 2013 Altera Corporation.
# $Header: //acds/rel/13.1/quartus/ccl/py/qhd_api.py#1 $

"""
Bottle routes for qhd API
"""

__author__ = "Seth Koehler (skoehler@altera.com)"
__version__ = "$Revision: #1 $"
__date__ = "$Date: 2013/08/11 $"
__copyright__ = "Copyright 2013 Altera Corporation."

import json
from bottle import route, get, post, request

from quartus.tlock import thread_lock

VERSION = "v1"


@get("/api/%s/qhd/partitions/" % VERSION)
@thread_lock
def get_all_partitions():
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')
    
    from quartus import qhd

    return qhd.get_all_user_partitions()

@get("/api/%s/qhd/partitions_hierarchy/" % VERSION)
@thread_lock
def get_all_partitions_hierarchy():
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')
    
    from quartus import qhd

    return qhd.get_all_user_partitions_hierarchy()

@get("/api/%s/qhd/logical_hierarchy/<root_partition>/" % VERSION)
@thread_lock
def get_all_logical_hierarchy(root_partition):
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')
    
    from quartus import qhd

    return qhd.get_logical_hierarchy(root_partition)

@post("/api/%s/qhd/partitions/" % VERSION)
@thread_lock
def create_partition():
    hpath = request.forms.get('hpath')

    return qhd.create_partition(hpath)


@get("/api/%s/qhd/partitions/<partition_id:int>/snapshots/" % VERSION)
@thread_lock
def get_available_snapshots(partition_id):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd
    
    return qhd.get_available_partition_snapshots(partition_id)
 
@get("/api/%s/qhd/partitions/<partition_id:int>/snapshots/<snapshot>/<iteration:int>/resources/" % VERSION)
@thread_lock
def report_partition_resources(partition_id, snapshot, iteration):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd
    
    return qhd.report_partition_resources(partition_id, snapshot, iteration)

@get("/api/%s/qhd/partitions/<partition_id:int>/snapshots/<snapshot>/<iteration:int>/names/" % VERSION)
@thread_lock
def get_partition_names(partition_id, snapshot, iteration):
	# TODO: Remove this once it's no longer necessary
	from quartus import dll_loader
	dll_loader.load('comp_qhd_qhd')
    
	from quartus import qhd
    
	depth_limit = request.query.get('depth')

	if depth_limit == None:
		return qhd.get_partition_names(partition_id, snapshot, iteration, -1)
	else:
		return qhd.get_partition_names(partition_id, snapshot, iteration, int(depth_limit))
    

@get("/api/%s/qhd/partitions/<partition_id:int>/snapshots/<snapshot>/<iteration:int>/names/<name_id:int>/options/" % VERSION)
@thread_lock
def get_options_on_name(partition_id, snapshot, iteration, name_id):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')
    
    from quartus import qhd
    
    option = request.query.get('option')

    if option == None:
        return qhd.get_options_on_name(partition_id, snapshot, iteration, name_id)
    else:
        return qhd.resolve_option_on_name(partition_id, snapshot, iteration, name_id, option)


@post("/api/v1/flow/<flow_name:re:[^0-9].*>")
@thread_lock
def start_flow(flow_name):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    # Get JSON body
    json_body_str = request.body.read().decode()
   
    from quartus import qhd
    try:
        flow_id = qhd.start_flow(flow_name, json_body_str)
    except RuntimeError as e:
        result = { 'success' : False, 'message' : str(e) }
    else:
        result = { 'success' : True, 'flow_id': flow_id }

    return result


@get("/api/v1/flow/")
@thread_lock
def get_all_flow_status():
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd
    return qhd.get_all_flow_status()

@get("/api/v1/flow/<flow_id:int>")
@thread_lock
def get_flow_simple_state(flow_id):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd
    
    return qhd.get_flow_simple_state(flow_id)


@get("/api/v1/flow/<flow_id:int>/messages/")
@thread_lock
def get_flow_messages(flow_id):
    # SQLite rejected queries for some reason when the sequence ID was set
    # to be as large as possible (sys.maxsize), so we artificially cap the
    # highest message ID at one billion, which should be large enough
    MAX_MESSAGE_SEQUENCE_ID = 1000000000

    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd

    start_id = 0
    end_id = MAX_MESSAGE_SEQUENCE_ID

    if request.query.start_id:
        start_id = int(request.query.start_id)

    if request.query.end_id:
        end_id = min(int(request.query.end_id), MAX_MESSAGE_SEQUENCE_ID)

    return qhd.get_flow_messages(flow_id, start_id, end_id)


@get("/api/v1/flow/<flow_id:int>/status/")
@thread_lock
def get_flow_detailed_status(flow_id):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd
    
    return qhd.get_flow_status(flow_id)


# TODO: Decide whether this should be in its own qdb module or not.  It is TBD
# whether we generally want QDB functionality directly exposed or not (at least
# in my head anyway).
@route("/api/v1/qdb/contents/")
@thread_lock
def list_qdb_contents():
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('db_qdb_qdb')
    dll_loader.load('comp_qhd_qhd')

    from quartus import qdb
    from quartus import qhd
    
    # For now we just get the QDB contents of the currently open project,
    # although we may wish to get other QDB contents in the future.
    if (qhd.get_current_project_name()):
        qdb_contents = qdb.get_contents(qhd.get_current_project_path())
    else:
        # No contents to return if project not open
        qdb_contents = { }
    
    return qdb_contents

@get("/api/v1/flow/<flow_id:int>/machine/")
@thread_lock
def get_flow_machine_info(flow_id):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd
    
    return qhd.get_flow_machine_info(flow_id)


@get("/api/v1/flow_table/")
@thread_lock
def get_all_flow_data_in_table():
    flow_table = []

    all_flow_status_json = get_all_flow_status()
    all_flow_status = json.loads(all_flow_status_json);

    for flow_id in all_flow_status.keys():
        record = all_flow_status[flow_id]
        record['flow_id'] = flow_id

        for (subflow_id, subflow_record) in enumerate(record['subflows']):
            subflow_record['flow_id'] = str(flow_id) + '.' + str(subflow_id)
            flow_table.append(subflow_record)

        flow_table.append(record)

    return { 'flows' : flow_table }


@get("/api/v1/flow/<flow_id:int>/partition/")
@thread_lock
def get_flow_partition_info(flow_id):
    # TODO: Remove this once it's no longer necessary
    from quartus import dll_loader
    dll_loader.load('comp_qhd_qhd')

    from quartus import qhd
    
    return qhd.get_flow_partition_info(flow_id)


